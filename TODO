- We can face race condition when we call erlang.call and send a message from
  Erlang at the same time. In this case instead of a function result we can get
  the message.

- It seems we need to use call IDs so we can handle multiple calls at once and
  avoid deadlocks in erlang._call. And when we wait for response in
  erlang._call we should probably queue other responses (allow only incoming
  calls and messages) for later processing.

- Do we really need erlang.make_ref() function?

- Add delete_(encode|decode|message_handler) functions for API clarity?

- Support erlport:cast for all languages

- We can redirect all unknown messages to the external language message
  handler.

- On error in the message handler we should shutdown the port by sending the
  special 'error_exit' message.

- Probably we don't need 'async' option for call() in this case because it can
  be replaced with send() function.

- Allow not only atoms in call() functions and Atom() classes. Convert strings,
  unicode(?) to atoms. Test functions with Unicode names.

- Add more API for middleware scenario (python, ruby). Reraise the language
  related exceptions in every module. And allow to start a language instance on
  other nodes.

- Ruby encoder/decoder for arguments/results

- Add custom encode/decode handlers in Erlang? Should it be a callback module?

- Set default timeout to 5 sec?

- Add [{timeout, Timeout}] options for erlang.call() function

- Allow calls in selected processes in Erlang. We can create a class
  (erlang.Process) which has call and exit methods. If Erlang process will die
  we just raise 'noproc' error.

- Split Erlang tests by languages? For example it can be useful if some of the
  languages not installed.

- Comments for modules

- Check all TODO/FIXME comments

- We need more robust error identification in erlport:spawn_call?

- erlport:server_name/0 and erlport:server_instances() types should be moved to
  some utils module? Maybe move types to a header file because -export_type
  seems doesn't work as expected in Erlang R13

- Test with R16

Later
=====

- Threaded mode with numbered requests. We can use distinct callback module
  in this case.

- Support for other languages (Perl, Lua, ?).

- Ruby 2.0 support

Ideas
=====

- We can add erlang.receive() function which waits for next message with
  optional timeout (timeouts can be implemented with select/etc. modules and
  probably with msvcrt.kbhit() on Windows). What about Ruby?

- Can we allow method calls for objects? For example we can pass a tuple
  {object, Object} instead of a module name?

- We can create references for unpicklable objects (and all objects through the
  explicit API). And we can create proxy objects this way. Need to think about
  garbage collection however.

- Add xref checks?

- More methods for Ruby's Tuple class?

- Add a pub/sub framework?

- Add workers_pool module with pluggable workers selection policies?

- Maybe it's possible to create an ErlPort interface which loads dynamic
  libraries?
