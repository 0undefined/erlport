- Extract (python|ruby)_options_tests:write_file() to erlport_test_utils

- Maybe split Python 2/3 tests to a distinct modules? And the same for Ruby
  1.8/1.9.

- Fix Python/Ruby path tests on Windows. We can add functions for testing
  paths which work with lists of path parts.

- Add support for Ruby 1.9+

- Allow only unidirectional subscriptions by default and make bidirectional
  subscriptions optional?

- Need add messagehub:reply functions

- Maybe we need to return 'cast' function? But can it also be done with
  publish/subscribe framework? Cast can be especially useful for external
  languages where we can use Erlang Pids to send messages to Erlang processes.
  Maybe we can add 'cast'/'send' only on external language side where we can use
  PIDs or registered names for the processes?

- Can we configure buffer size at the process start?

- Add xref checks?

- erlport:server_name/0 and erlport:server_instances() types should be moved to
  some utils module? Maybe move types to a header file because -export_type
  seems doesn't work as expected in Erlang R13

- Support message handling in messagehub and erlport

- How we should support external functions in sender and destination lists for
  messages? Probably it should be {ErlporPid, ModuleFunctionString} tuples.
  This way we can store anything as the second item.

- Maybe we need to reduce/optimize number of messages sent as
  subscribe/unsubscribe events? Probably we can send only one
  subscribed/unsubscribed message with list of topics.

- Add subscriber behaviour so we can abstract message hubs

- (Ruby) Can EmptySymbol be subclassed from Symbol?

- Ruby Erlang::call method

- Ruby encoder/decoder for arguments/results

- Redefine STDOUT/STDIN in Python/Ruby and ignore/log output? We can add option
  'redirect_stdout' (and maybe 'stderr_to_stdout') and in this case redirect
  Python/Ruby/... STDOUT to Erlang as messages. In other case just raise an
  error. STDIN should always raise an error.

- Create some tools for debuggig external programs? Like logging to file etc.

- Can we support some environment variables? For example to control Python
  executable? But there's a problem with environment variables and options
  precedence.

- Should we use "modern" API on Python side? We can leave only Erlang.call()
  function.

- Allow calls in selected processes in Erlang. We can use arbitrary keys on
  Python/Ruby side and control process creation/mapping/cleanup on Erlang side.

  API: Erlang[Pid].module.function(args)

  Add options to erlang.call: [{key, aProcessKey}, {timeout, Timeout}].

  If process will die we just return 'noproc' error and raise it on the
  Python/Ruby side.

- Log some errors (for example if switch failed in async mode) and just
  continue. If port was closed and we have an error to report we can try to
  report it with logging module

- Add 'threaded' mode for switch and run switch call in threads in Python. What
  is the use case for this mode? Threads:

  - Receive thread
  - Call Python thread
  - Call Erlang threads. We can use round-robin to send messages through Erlang
    call threads.

- Add custom encode/decode handlers in Erlang

- Add worker_pool module with pluggable workers selection policies

- How to handle Python <-> Python exceptions? We can pass it inside some error
  term. Errors/exceptions should be like opaque types marked with the language
  but store some known structures as values

- Comments for modules

Later
=====

- Perl support. What about different Perl versions?

- Maybe it's possible to create an ErlPort interface which loads dynamic
  libraries?
