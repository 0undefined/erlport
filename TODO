- call should support 'stop_on_error' (async?) option from both sides

- Allow not only atoms in call() functions, convert strings, unicode(?) to
  atoms. Test functions with Unicode names.

- Can we allow method calls for objects? For example we can pass a tuple
  {object, Object} instead of a module name?

- We can create references for unpicklable objects (and all objects through the
  explicit API). And we can create proxy objects this way? Need to think about
  garbage collection however.

- It seems 'print' messages doesn't work with Unicode characters right now?

- Add more API for middleware scenario (python, ruby, workers_pool, msghub
  modules). Reraise the language related exceptions in every module. And
  allow to start a language instance on other nodes. Probably we also can
  allow creation of remote objects if object references will be available.

- Ruby encoder/decoder for arguments/results

- Add custom encode/decode handlers in Erlang? Should it be a callback module?

- Set default timeout to 5 sec?

- Rename messagehub to msgrouter?

- Maybe pub/sub should be allowed only for Erlang?

- Rules for pub/sub messages handling:

  - It's better to use Erlang subscribers and call them with an API from
    external languages. For example request/response can be handled easily in
    this case just as a function call.
  - Probably request/response can be handled by switching ErlPort to server
    mode with some external subscriber which handles timeouts. But for this to
    work external subscriber should monitor all the messages even private ones.
  - Possible threaded mode can be used for full duplex messaging?

- Allow only unidirectional subscriptions by default and make bidirectional
  subscriptions optional??

- Need add messagehub:reply functions

- Support message handling in messagehub and erlport

- How we should support external functions in sender and destination lists for
  messages? Probably it should be {ErlporPid, ModuleFunctionString} tuples.
  This way we can store anything as the second item.

- We need to reduce/optimize number of messages sent as subscribe/unsubscribe
  events. We can send only one subscribed/unsubscribed message with list of
  topics.

- Add subscriber behaviour so we can abstract message hubs

- Allow calls in selected processes in Erlang. We can use arbitrary keys on
  Python/Ruby side and control process creation/mapping/cleanup on Erlang side.

  API: Erlang[Key].module.function(args)

  Add options to erlang.call: [{key, Key}, {timeout, Timeout}].

  If process will die we just return 'noproc' error and raise it on the
  Python/Ruby side.

  We also can create a class (erlang.Process) with call and exit methods. In
  this case working process should be created explicitly and we can pass
  the pid to erlang.call?

- Add workers_pool module with pluggable workers selection policies

- Comments for modules

- Check all TODO/FIXME comments

- We need more robust error identification in erlport:spawn_call?

- erlport:server_name/0 and erlport:server_instances() types should be moved to
  some utils module? Maybe move types to a header file because -export_type
  seems doesn't work as expected in Erlang R13

Later
=====

- Threaded mode with numbered requests. We can use distinct callback module
  in this case.

- Support for other languages (Perl, Lua, ?).

Ideas
=====

- Add xref checks?

- More methods for Ruby's Tuple class?

- Maybe it's possible to create an ErlPort interface which loads dynamic
  libraries?
