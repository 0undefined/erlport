- Maybe we need to split request/response data if we can't send it?

- We need check queue more than one time

- Optionally call Erlang functions in one process without spawning new process
  for each call?

- We don't need to add 'switch' function in Python just switching back to
  Erlang when switched Python function is over

- Thread safety in Python?

- Handler Python call timeouts on Erlang side.

- It seems we don't need server/client mode in Python and Python init function.
  We can add switch(Module, Function, Args) function which pass control to the
  other side by calling the Function with a special message like the cast
  message. But what to do if we call switch from Python during call processing?
  We can raise an exception on Python side or interrupt the call and return an
  Interrupted exception to Erlang. It seems the same apply to the Erlang side
  too.

- We can to return errors (like already in client mode) for switch in client
  mode and for call/cast in client mode. Maybe we don't need to return
  errors for 'cast' calls

- Don't forget to order message handling functions by mos frequently used
  messages

- We can return errors from cast/switch functions as a special message and just
  stop Erlang process

- Add ping() method with 'P' request and 'p' response. Or just some binary
  request/response like 00/01?

- Periodically call ping() on timeouts (when there is no messages for some
  time)?

- Add info() function with statistics and information, for example number
  of requests/responses, number of sent/received bytes, number of
  error for requests/responses, uptime?

- Create monitor and timer for Erlang function and wait for result. If timeout
  occurs we can return error

- Convert some tuples to records in python.erl

- Update tests for Python

- Maybe module name should be list of atoms? Like [os, path] instead of
  'os.path'.

- Comments for modules

- Add 'compressed' option

- Use bigger buffer for port in Python

- We can allow to send some number (configurable?) of backlog request while
  we waiting for response. We just can use 'nosuspend' options for port_command

- Add opaque type {opaque, Type :: erlang | python, Data :: binary()} and
  unpack Data depending on Type.

- Add {'cd', Dir} option to python:start(_link)/1

- How to handle Python <-> Python exceptions?

- Call timeouts

- Check default port options on Windows

- Can we request attributes also, like
  python:call(P, 'sys.modules', get, [<<"sys">>])?

- Add some type functions on Erlang side. Like
  python_types:module("__builtins__")??

- Add ready to use function to return attribute of objects in Python.
  Should it be added to erlport.py/python.py or just erlang.py?

- Maybe force strings with {string, String}?

- Need a way to start a Python function on Python start. It's mandatory for
  with 'server' option and also optional init function can be specified in
  client mode.

- Pluggable encoders/decoders? We can register proxy encoder/decoder functions.

- Reduce number of supported types.

- Support also argparse along with optparse in Python? Or rework erlport.cli?

- Python 3, other languages?

- Maybe we can try variable length length field as in
  Twisted Banana/Protocol Buffers protocols

- Maybe we can cache atoms or module/function? But it also can be slower.


- Periodically check if channel is alive in Python? Seems unneeded because we
  always trying read or write

- Add workers_pool module with pluggable workers selection policies

- Errors/exceptions should be like opaque types marked with the language
  but store some known structures as values

- Marks errors/exception with some ID? Like (node(), self(), OS PID) for Python
  and (node(), self()) for Erlang?

- Check port_command for 'badarg' exception

- Type: 'undefined' <-> None

- Check term_to_binary/1 calls for errors
