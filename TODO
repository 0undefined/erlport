- Maybe we need to return 'cast' function? But it also can be done with
  publish/subscribe framework?

- Messages should be defined by records

- erlport:server_name/0 and erlport:server_instances() types should be moved to
  some utils module? Maybe move types to a header file because -export_type
  seems doesn't work as expected in Erlang R13

- For direct messages destination can be represented by a list of hops. For
  example [ErlPortPid, ExternalFunctionName]. And we can optionaly send message
  for full path or just directly to the final Pid. And it seems message source
  also need to be represent by a list.

- Use monitors instead of links in message hub

- Add subscriber behaviour so we can abstract message hubs

- (Ruby) Can EmptySymbol be subclassed from Symbol?

- What about different Ruby versions?

- Ruby Erlang::call method

- Ruby encoder/decoder for arguments/results

- Redefine STDOUT/STDIN in Python/Ruby and ignore/log output? We can add option
  'redirect_stdout' (and maybe 'stderr_to_stdout') and in this case redirect
  Python/Ruby/... STDOUT to Erlang as messages. In other case just raise an
  error. STDIN should always raise an error.

- Create some tools for debuggig external programs? Like logging to file etc.

- Can we support some environment variables? For example to control Python
  executable? But there's a problem with environment variables and options
  precedence.

- Allow calls in selected processes in Erlang. For example we can add
  erlang.create_call_processes(n=1) -> [pid()] function and select it like
  this:

  Erlang[Pid].module.function(args)

  In low-level API it should be in options to erlang.call

  However need to think about garbage collection of Pids.

- Add options to erlang.call: [{pid, Pid (special working process)}, {timeout,
  Timeout}]

- Log some errors (for example if switch failed in async mode) and just
  continue. If port was closed and we have an error to report we can try to
  report it with logging module

- Add 'threaded' mode for switch and run switch call in threads in Python. What
  is the use case for this mode? Threads:

  - Receive thread
  - Call Python thread
  - Call Erlang threads. We can use round-robin to send messages through Erlang
    call threads.

- Add custom encode/decode handlers in Erlang

- Add worker_pool module with pluggable workers selection policies

- How to handle Python <-> Python exceptions? We can pass it inside some error
  term. Errors/exceptions should be like opaque types marked with the language
  but store some known structures as values

- Check default port options on Windows. Return error for 'nouse_stdio' option
  on Windows? It seems this option unsupported or have no effect on Windows?

- Perl support. What about different Perl versions?

- Comments for modules

- Refactor tests?
