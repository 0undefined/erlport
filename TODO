- call should support 'stop_on_error' (async?) option from both sides

- Threaded mode with numbered requests. We can use distinct callback module
  in this case.

- Maybe we don't need two modes? We can just leave only erlport:call and warn
  users about possible deadlock problems?

- Ruby encoder/decoder for arguments/results

- Add custom encode/decode handlers in Erlang? Should it be a callback module?

- Maybe split Python 2/3 tests to distinct modules? And the same for Ruby
  1.8/1.9.

- Add support for Ruby 1.9+

- Rename messagehub to msgrouter?

- Maybe pub/sub should be allowed only for Erlang?

- Rules for pub/sub messages handling:

  - We should drop pub/sub messages if erlport in server mode;
  - Messages should be delivered as 'switch' calls so external language can
    send a possible response call
  - It's better to use Erlang subscribers and call them with an API from
    external languages. For example request/response can be handled easily in
    this case just as a function call.
  - Probably request/response can be handled by switching ErlPort to server
    mode with some external subscriber which handles timeouts. But for this to
    work external subscriber should monitor all the messages even private ones.
  - Possible threaded mode can be used for full duplex messaging?

- Allow only unidirectional subscriptions by default and make bidirectional
  subscriptions optional?

- Need add messagehub:reply functions

- Support message handling in messagehub and erlport

- How we should support external functions in sender and destination lists for
  messages? Probably it should be {ErlporPid, ModuleFunctionString} tuples.
  This way we can store anything as the second item.

- We need to reduce/optimize number of messages sent as subscribe/unsubscribe
  events. We can send only one subscribed/unsubscribed message with list of
  topics.

- Add subscriber behaviour so we can abstract message hubs

- Allow calls in selected processes in Erlang. We can use arbitrary keys on
  Python/Ruby side and control process creation/mapping/cleanup on Erlang side.

  API: Erlang[Key].module.function(args)

  Add options to erlang.call: [{key, Key}, {timeout, Timeout}].

  Can we select timeouts with the modern API? For example to create the root
  object with some timeout?

  If process will die we just return 'noproc' error and raise it on the
  Python/Ruby side.

- Add workers_pool module with pluggable workers selection policies

- Comments for modules

- Check all TODO/FIXME comments

- We need more robust error identification in erlport:spawn_call?

- erlport:server_name/0 and erlport:server_instances() types should be moved to
  some utils module? Maybe move types to a header file because -export_type
  seems doesn't work as expected in Erlang R13

Ideas
=====

- Add xref checks?

- More methods for Ruby's Tuple class?

- Add 'threaded' mode for switch (and call with a thread pool?)?

- Support for other languages (Perl, Lua, ?).

- Maybe it's possible to create an ErlPort interface which loads dynamic
  libraries?
