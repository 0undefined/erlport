- And tests for all CallError scenarios (especially calls between languages)
  for all languages

- Support STDOUT/STDIN redirection for all languages and add tests.

- We can support ERLPORT_PYTHON/ERLPORT_RUBY environment variables.

- Ruby's Tuple class should not be just a marker class

- Check all TODO/FIXME comments

- Maybe split Python 2/3 tests to distinct modules? And the same for Ruby
  1.8/1.9.

- Add support for Ruby 1.9+

- Allow only unidirectional subscriptions by default and make bidirectional
  subscriptions optional?

- Need add messagehub:reply functions

- Maybe we need to return 'cast' function? But can it also be done with
  publish/subscribe framework? Cast can be especially useful for external
  languages where we can use Erlang Pids to send messages to Erlang processes.
  Maybe we can add 'cast'/'send' only on external language side where we can use
  PIDs or registered names for the processes?

- Can we configure buffer size at the process start?

- erlport:server_name/0 and erlport:server_instances() types should be moved to
  some utils module? Maybe move types to a header file because -export_type
  seems doesn't work as expected in Erlang R13

- Support message handling in messagehub and erlport

- How we should support external functions in sender and destination lists for
  messages? Probably it should be {ErlporPid, ModuleFunctionString} tuples.
  This way we can store anything as the second item.

- We need to reduce/optimize number of messages sent as subscribe/unsubscribe
  events. We can send only one subscribed/unsubscribed message with list of
  topics.

- Add subscriber behaviour so we can abstract message hubs

- Ruby Erlang::call method

- Ruby encoder/decoder for arguments/results

- Should we use "modern" API on Python side? We can leave only Erlang.call()
  function.

- Allow calls in selected processes in Erlang. We can use arbitrary keys on
  Python/Ruby side and control process creation/mapping/cleanup on Erlang side.

  API: Erlang[Key].module.function(args)

  Add options to erlang.call: [{key, Key}, {timeout, Timeout}].

  Can we select timeouts with the modern API? For example to create the root
  object with some timeout?

  If process will die we just return 'noproc' error and raise it on the
  Python/Ruby side.

- Log some errors (for example if switch failed in async mode) and just
  continue. If port was closed and we have an error to report we can try to
  report it with logging module

- Add 'threaded' mode for switch and run switch call in threads in Python. What
  is the use case for this mode? And not only for switch mode:

  - We can always allow unordered responses. For example we can store requests
    with IDs in a special queue with random access.
  - The 'threads' option can set the number of threads in the external threads
    pool (0 for not using threads).

  Threads:

  - Main receive thread
  - Pool of Python/Ruby/etc threads

  What about switch mode?

- Add custom encode/decode handlers in Erlang

- Add worker_pool module with pluggable workers selection policies

- Comments for modules

Later
=====

- Add xref checks?

Ideas
=====

- Perl support. What about different Perl versions?

- Maybe it's possible to create an ErlPort interface which loads dynamic
  libraries?
