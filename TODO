- It should be possible to call erlang.modules.Module.Function like functions
  from Erlang. We should split function name by '.'

- Add custom encode/decode handlers in Erlang

- Test coverage for Erlang

- Xref warnings for Erlang?

- Use struct.Struct for erlterms.encode

- Hide erlang.call and rename erlang.modules to erlang.Erlang?

- Check if pickle formats are compatible between different Python versions

- Convert Python tests from doctests to unittest

- Check exports in erlport/__init__.py

- Add lock for erlang.call and maybe for erlang.receive?

- Check Python version by calling python -V

- Maybe return expected type in case of option error?

- Check code with older versions of Erlang/Python

- Update tests for Python. Add tests for all data types for Erlang <-> Python

- Comments for modules

- How to handle Python <-> Python exceptions? We can pass it inside some error
  term. Errors/exceptions should be like opaque types marked with the language
  but store some known structures as values

- Check default port options on Windows

- Maybe force strings with {string, String} and {struct, Dict}? It can be done
  with pluggable encoder/decoder. We can add 'reach' encoder/decoder plugin
  functions

- Support argparse instead of optparse on Python 3?

- Python 3, other languages? Ruby? What about different Ruby versions?

- Add worker_pool module with pluggable workers selection policies

- Maybe we can try variable length length field as in Twisted Banana/Protocol
  Buffers protocols?
