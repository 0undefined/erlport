- Check Python version by calling python -V

- Maybe return expected type in case of option error?

- Check code with older versions of Erlang/Python

- Maybe configure threads for Python request handler? For example "run 4
  threads for request handling".

- Add ID to requests? Calls from Python can be multi-threaded for example and
  it can be good if we will support pippelined requests

- Optionally call Erlang functions in one process without spawning new process
  for each call?

- Thread safety in Python?

- Add info() function with statistics and information, for example number
  of requests/responses, number of sent/received bytes, number of
  errors for requests/responses, uptime?

- Convert some tuples to records in python.erl

- Update tests for Python. Add tests for all data types for Erlang <-> Python

- Comments for modules

- Add 'compressed' option

- Use bigger buffer for port in Python

- We can allow to send some number (configurable?) of backlog request while
  we waiting for response. We just can use 'nosuspend' options for port_command

- Add {'cd', Dir} option to python:start(_link)/1. And make absolute names
  for python path.

- How to handle Python <-> Python exceptions? We can pass it inside some error
  term. Errors/exceptions should be like opaque types marked with the language
  but store some known structures as values

- Check default port options on Windows

- Maybe force strings with {string, String}? Check with JSON EEP?

- Pluggable encoders/decoders? We can register proxy encoder/decoder functions.
  If encoder/decoder is defined we just scan through hierarchy of objects and
  call encoder/decoder for each object.

- Support argparse instead of optparse on Python 3?

- Python 3, other languages? Ruby? What about different Ruby versions?

- Maybe we can try variable length length field as in
  Twisted Banana/Protocol Buffers protocols

- Add workers_pool module with pluggable workers selection policies
