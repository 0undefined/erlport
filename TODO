- Two modes of operation:

  - Call and cast from Erlang

  - Call and cast from Python with user supplied script

- We can store already encoded request in the request queue

- We can allow to send some number (configurable?) of backlog request while
  we waiting for response

- Add opaque type {opaque, Type :: erlang | python, Data :: binary()} and
  unpack Data depending on Type.

- Add {'cd', Dir} option to python:start(_link)/1

- How to handle Python <-> Python exceptions?

- Call timeouts

- Check default port options on Windows

- Can we request attributes also, like
  python:call(P, 'sys.modules', get, [<<"sys">>])?

- Add some type functions on Erlang side. Like
  python_types:module("__builtins__")??

- Add ready to use function to return attribute of objects in Python.
  Should it be added to erlport.py/python.py or just erlang.py?

- Maybe force strings with {string, String}?

- Need a way to start a Python code on Python start

- Pluggable encoders/decoders? We can register proxy encoder/decoder functions.

- Reduce number of supported types.

- Support also argparse along with optparse in Python? Or rework erlport.cli?

- Python 3, other languages?

- Maybe we can try variable length length field as in
  Twisted Banana/Protocol Buffers protocols

- Maybe we can cache atoms or module/function but it also can be slower?

- Periodically check if channel is alive in Python? Seems unneeded because we
  always trying read or write
