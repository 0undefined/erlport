- call should support 'stop_on_error' (async?) option from both sides

- Allow not only atoms in call() functions, convert strings, unicode(?) to
  atoms. Test functions with Unicode names.

- It seems 'print' messages doesn't work with Unicode characters right now?

- Split CallError into subclasses: ErlangError, PythonError, RubyError

- Add more API for middleware scenario. For example modules for every language,
  like: python.start(). The API of the returned object can be inspired by
  Thread/multiprocess API? RPC can reraise the right exceptions with this API.
  Should we allow only RPC or proxy objects also can be allowed? And
  python.start() can also start Python on other nodes. And also we can allow
  creation of load balansers and messages routers through external language
  API?

- Ruby encoder/decoder for arguments/results

- Add custom encode/decode handlers in Erlang? Should it be a callback module?

- Maybe split Python 2/3 tests to distinct modules? And the same for Ruby
  1.8/1.9.

- Add support for Ruby 1.9+

- Rename messagehub to msgrouter?

- Maybe pub/sub should be allowed only for Erlang?

- Rules for pub/sub messages handling:

  - It's better to use Erlang subscribers and call them with an API from
    external languages. For example request/response can be handled easily in
    this case just as a function call.
  - Probably request/response can be handled by switching ErlPort to server
    mode with some external subscriber which handles timeouts. But for this to
    work external subscriber should monitor all the messages even private ones.
  - Possible threaded mode can be used for full duplex messaging?

- Allow only unidirectional subscriptions by default and make bidirectional
  subscriptions optional??

- Need add messagehub:reply functions

- Support message handling in messagehub and erlport

- How we should support external functions in sender and destination lists for
  messages? Probably it should be {ErlporPid, ModuleFunctionString} tuples.
  This way we can store anything as the second item.

- We need to reduce/optimize number of messages sent as subscribe/unsubscribe
  events. We can send only one subscribed/unsubscribed message with list of
  topics.

- Add subscriber behaviour so we can abstract message hubs

- Allow calls in selected processes in Erlang. We can use arbitrary keys on
  Python/Ruby side and control process creation/mapping/cleanup on Erlang side.

  API: Erlang[Key].module.function(args)

  Add options to erlang.call: [{key, Key}, {timeout, Timeout}].

  If process will die we just return 'noproc' error and raise it on the
  Python/Ruby side.

- Add workers_pool module with pluggable workers selection policies

- Comments for modules

- Check all TODO/FIXME comments

- We need more robust error identification in erlport:spawn_call?

- erlport:server_name/0 and erlport:server_instances() types should be moved to
  some utils module? Maybe move types to a header file because -export_type
  seems doesn't work as expected in Erlang R13

Later
=====

- Threaded mode with numbered requests. We can use distinct callback module
  in this case.

- Support for other languages (Perl, Lua, ?).

Ideas
=====

- Add xref checks?

- More methods for Ruby's Tuple class?

- Maybe it's possible to create an ErlPort interface which loads dynamic
  libraries?
