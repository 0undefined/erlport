- Add __hash__ and __eq__ methods to some erlterms.(py|rb) classes

- Allow calls in selected processes in Erlang. For example we can add
  erlang.create_call_processes(n=1) -> [pid()] function and select it like
  this:

  Erlang[Pid].module.function(args)

  In low-level API it should be in options to erlang.call

  However need to think about garbage collection of Pids.

- Add options to erlang.call: [{pid, Pid (special working process)}, {timeout,
  Timeout}]

- Fix testall

- Log some errors (for example if switch failed in async mode) and just
  continue. If port was closed and we have an error to report we can try to
  report it with logging module

- Refactor tests

- Return error for 'nouse_stdio' option on Windows? It seems this option
  unsupported or have no effect on Windows?

- Add publish/subscribe mode with direct messaging support? Pids, funs, MFAs
  can be subscribed in Erlang and callable objects in Python:

  subscribe(Topic (atom() or any type?), pid() | function() | {M, F, A})
  unsubscribe(Topic, Subscriber)
  publish(Topic | Subscriber, Message) (or send?)

  Should we add ID to published messages?

- Add 'threaded' mode for switch and run switch call in threads in Python. What
  is the use case for this mode? Threads:

  - Receive thread
  - Call Python thread
  - Call Erlang threads. We can use round-robin to send messages through Erlang
    call threads.

- Add custom encode/decode handlers in Erlang

- Convert Python tests from doctests to unittest

- Check exports in erlport/__init__.py

- Comments for modules

- How to handle Python <-> Python exceptions? We can pass it inside some error
  term. Errors/exceptions should be like opaque types marked with the language
  but store some known structures as values

- Check default port options on Windows

- Maybe force strings with {string, String} and {struct, Dict}? It can be done
  with pluggable encoder/decoder. We can add 'reach' encoder/decoder plugin
  functions

- Other languages? Ruby? What about different Ruby versions?

- Add worker_pool module with pluggable workers selection policies

Later
-----

- Maybe we can try variable length length field as in Twisted Banana/Protocol
  Buffers protocols?

- After some number of subscribers we can create publishing workers (with
  (un)subscribe/publish functions) which can publish messages in parallel.
