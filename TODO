- Split Erlang tests by languages? For example it can be useful if some of the
  languages not installed.

- Check how Unicode characters in symbols work in Ruby 1.9

- For internal usage we can add Pid argument to incoming call messages which
  can be 'new', 'local' or pid()

- Add registration for a message handler and send() (gen_server:cast) function
  for erlport.erl module. We also can redirect all unknown messages to the
  external language message handler. And probably we don't need 'async' option
  for call() in this case because it can be replaced with send() function. We
  can add erlang.receive() function which waits for next message with optional
  timeout.

- Add erlang.self() and maybe erlang.make_ref() functions? And can we call
  some (predefined?) functions inside the erlport process?

- call should support 'stop_on_error' (async?) option from both sides?? Maybe
  we can use messages in this case and remove support for async calls?

- Allow not only atoms in call() functions and Atom() classes. Convert strings,
  unicode(?) to atoms. Test functions with Unicode names.

- Can we allow method calls for objects? For example we can pass a tuple
  {object, Object} instead of a module name?

- Add more API for middleware scenario (python, ruby, workers_pool, msghub
  modules). Reraise the language related exceptions in every module. And
  allow to start a language instance on other nodes. Probably we also can
  allow creation of remote objects if object references will be available.

- Ruby encoder/decoder for arguments/results

- Add custom encode/decode handlers in Erlang? Should it be a callback module?

- Set default timeout to 5 sec?

- Allow calls in selected processes in Erlang. We can use arbitrary keys on
  Python/Ruby side and control process creation/mapping/cleanup on Erlang side.

  API: Erlang[Key].module.function(args)

  Add options to erlang.call: [{key, Key}, {timeout, Timeout}].

  If process will die we just return 'noproc' error and raise it on the
  Python/Ruby side.

  We also can create a class (erlang.Process) with call and exit methods. In
  this case working process should be created explicitly and we can pass
  the pid to erlang.call?

- Comments for modules

- Check all TODO/FIXME comments

- We need more robust error identification in erlport:spawn_call?

- erlport:server_name/0 and erlport:server_instances() types should be moved to
  some utils module? Maybe move types to a header file because -export_type
  seems doesn't work as expected in Erlang R13

Later
=====

- Threaded mode with numbered requests. We can use distinct callback module
  in this case.

- Support for other languages (Perl, Lua, ?).

- Ruby 2.0 support

Ideas
=====

- We can create references for unpicklable objects (and all objects through the
  explicit API). And we can create proxy objects this way. Need to think about
  garbage collection however.

- Add xref checks?

- More methods for Ruby's Tuple class?

- Add a pub/sub framework?

- Add workers_pool module with pluggable workers selection policies?

- Maybe it's possible to create an ErlPort interface which loads dynamic
  libraries?
