- Add options list for call/switch so we can configure timeouts and
  waiting for result for switch for example

- Maybe return expected type in case of option error?

- Maybe we can register handler to handle switch function errors and result?

- Check code with older versions of Erlang/Python

- Use 'nosuspend' option only for pipelinend requests and suspend otherwise?

- Maybe configure threads for Python request handler? For example "run 4
  threads for request handling".

- Add ID to requests? Calls from Python can be multi-threaded for example and
  it can be good if we will support pippelined requests

- Optionally call Erlang functions in one process without spawning new process
  for each call?

- We don't need to add 'switch' function in Python just switching back to
  Erlang when switched Python function is over

- Thread safety in Python?

- Don't forget to order message handling functions by most frequently used
  messages

- We can return errors from cast/switch functions as a special message and just
  stop Erlang process

- Add ping() method with 'P' request and 'p' response. Or just some binary
  request/response like 00/01?

- Periodically call ping() on timeouts (when there is no messages for some
  time)?

- Add info() function with statistics and information, for example number
  of requests/responses, number of sent/received bytes, number of
  error for requests/responses, uptime?

- Convert some tuples to records in python.erl

- Update tests for Python

- Maybe module name should be list of atoms? Like [os, path] instead of
  'os.path'.

- Comments for modules

- Add 'compressed' option

- Use bigger buffer for port in Python

- We can allow to send some number (configurable?) of backlog request while
  we waiting for response. We just can use 'nosuspend' options for port_command

- Add opaque type {opaque, Type :: erlang | python, Data :: binary()} and
  unpack Data depending on Type.

- Add {'cd', Dir} option to python:start(_link)/1. And make absolute names
  for python path.

- How to handle Python <-> Python exceptions? We can pass it inside some
  error term.

- Call timeouts

- Check default port options on Windows

- Can we request attributes also, like
  python:call(P, 'sys.modules', get, [<<"sys">>])?

- Add some type functions on Erlang side. Like
  python_types:module("__builtins__")??

- Add ready to use function to return attribute of objects in Python.
  Should it be added to erlport.py/python.py or just erlang.py?

- Maybe force strings with {string, String}?

- Pluggable encoders/decoders? We can register proxy encoder/decoder functions.

- Reduce number of supported types.

- Support also argparse along with optparse in Python? Or rework erlport.cli?

- Python 3, other languages?

- Maybe we can try variable length length field as in
  Twisted Banana/Protocol Buffers protocols

- Maybe we can cache atoms or module/function? But it also can be slower.

- Add workers_pool module with pluggable workers selection policies

- Errors/exceptions should be like opaque types marked with the language
  but store some known structures as values

- Marks errors/exception with some ID? Like (node(), self(), OS PID) for Python
  and (node(), self()) for Erlang?

- Check port_command for 'badarg' exception

- Type: 'undefined' <-> None

- Add 'compressed' option
