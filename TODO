- Rename 'server' option to {main, PythonModule} and also add
  {init, PythonModule} which also can be called before client code.

- Maybe we need call init function through port so we can pass arguments to it?
  Maybe the same true for main function also? It seems we need some handshake
  protocol for this. Errors in Python init function can be returned as errors
  in python:init and errors in Python main function can be returned by
  a special message?

- We can return Python errors as a special message and just stop Erlang process

- Two modes of operation:

  - Call and cast from Erlang

  - Call and cast from Python with user supplied script

- Create monitor and timer for Erlang function and wait for result. If timeout
  occurs we can return error

- Convert some tuples to records in python.erl

- Update tests for Python

- Maybe module name should be list of atoms? Like [os, path] instead of
  'os.path'.

- Comments for modules

- Add 'compressed' option

- Use bigger buffer for port in Python

- We can allow to send some number (configurable?) of backlog request while
  we waiting for response. We just can use 'nosuspend' options for port_command

- Add opaque type {opaque, Type :: erlang | python, Data :: binary()} and
  unpack Data depending on Type.

- Add {'cd', Dir} option to python:start(_link)/1

- How to handle Python <-> Python exceptions?

- Call timeouts

- Check default port options on Windows

- Can we request attributes also, like
  python:call(P, 'sys.modules', get, [<<"sys">>])?

- Add some type functions on Erlang side. Like
  python_types:module("__builtins__")??

- Add ready to use function to return attribute of objects in Python.
  Should it be added to erlport.py/python.py or just erlang.py?

- Maybe force strings with {string, String}?

- Need a way to start a Python function on Python start. It's mandatory for
  with 'server' option and also optional init function can be specified in
  client mode.

- Pluggable encoders/decoders? We can register proxy encoder/decoder functions.

- Reduce number of supported types.

- Support also argparse along with optparse in Python? Or rework erlport.cli?

- Python 3, other languages?

- Maybe we can try variable length length field as in
  Twisted Banana/Protocol Buffers protocols

- Maybe we can cache atoms or module/function? But it also can be slower.


- Periodically check if channel is alive in Python? Seems unneeded because we
  always trying read or write

- Add workers_pool module with pluggable workers selection policies

- Errors/exceptions should be like opaque types marked with the language
  but store some known structures as values

- Marks errors/exception with some ID? Like (node(), self(), OS PID) for Python
  and (node(), self()) for Erlang?

- Add ping() method with 'P' request and 'p' response. Or just some binary
  request/response like 00/01?

- Add some handshake protocol? We can request OS PID for example?

- Periodically call ping() on timeouts (when there is no messages for some
  time)?

- Add info() function with statistics and information, for example number
  of requests/responses, number of sent/received bytes, number of
  error for requests/responses, uptime?

- Check port_command for 'badarg' exception

- Type: 'undefined' <-> None

- Check term_to_binary/1 calls for errors
